<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p>This vignette shows how to </p>

<ul>
<li>create a very simple RDF data cube from data and metadata<br/></li>
<li>query the cube using SPARQL</li>
<li>execute the RDF data cube integrity checks</li>
</ul>

<h1>Setup</h1>

<p>The next command is not needed if the package have been loaded throug devtools::load_all().</p>

<pre><code class="r">library(rrdfqbcrnd0)
</code></pre>

<h1>Create RDF data cube</h1>

<p>The RDF data cube will be created from two data.frames containing data and metadata.</p>

<h2>Define data</h2>

<p>The data are defined as data frame, and the data frame is displayed.</p>

<pre><code class="r">obsData&lt;- data.frame(
  category=c(&quot;AA-group&quot;, &quot;BB-group&quot;),
  procedure=c(&quot;count&quot;, &quot;count&quot; ),
  factor=c(&quot;quantity&quot;, &quot;quantity&quot; ),
  unit=c(&quot;subject&quot;, &quot;subject&quot; ),
  denominator=c(&quot; &quot;, &quot; &quot;),
  measure=c( 123, 456 ),
  stringsAsFactors=FALSE  )
knitr::kable(obsData)
</code></pre>

<table><thead>
<tr>
<th align="left">category</th>
<th align="left">procedure</th>
<th align="left">factor</th>
<th align="left">unit</th>
<th align="left">denominator</th>
<th align="right">measure</th>
</tr>
</thead><tbody>
<tr>
<td align="left">AA-group</td>
<td align="left">count</td>
<td align="left">quantity</td>
<td align="left">subject</td>
<td align="left"></td>
<td align="right">123</td>
</tr>
<tr>
<td align="left">BB-group</td>
<td align="left">count</td>
<td align="left">quantity</td>
<td align="left">subject</td>
<td align="left"></td>
<td align="right">456</td>
</tr>
</tbody></table>

<h2>Define meta data</h2>

<p>The metadata used for generating the RDF data cube are also defined as data frame and displayed.</p>

<pre><code class="r">cubeMetadata&lt;- data.frame(
  compType=c(&quot;dimension&quot;, &quot;dimension&quot;, &quot;dimension&quot;, &quot;unit&quot;, &quot;denominator&quot;, &quot;measure&quot;, &quot;metadata&quot;),
  compName=c(&quot;category&quot;, &quot;procedure&quot;, &quot;factor&quot;, &quot;attribute&quot;, &quot;attribute&quot;, &quot;measure&quot;, &quot;domainName&quot;),
  codeType=c(&quot;DATA&quot;, &quot;DATA&quot;, &quot;DATA&quot;, &quot; &quot;, &quot; &quot;, &quot;&lt;NA&gt;&quot;,&quot;&lt;NA&gt;&quot;),
  nciDomainValue=c(&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;, &quot; &quot;, &quot; &quot;,&quot; &quot;),
  compLabel=c(&quot;Category&quot;, &quot;Statistical procedure&quot;, &quot;Type of procedure&quot;, &quot;Result&quot;, &quot;Unit&quot;, &quot;Denominator&quot;, &quot;EXAMPLE&quot;),
  Comment=c(&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;),
  stringsAsFactors=FALSE  )
knitr::kable(cubeMetadata)
</code></pre>

<table><thead>
<tr>
<th align="left">compType</th>
<th align="left">compName</th>
<th align="left">codeType</th>
<th align="left">nciDomainValue</th>
<th align="left">compLabel</th>
<th align="left">Comment</th>
</tr>
</thead><tbody>
<tr>
<td align="left">dimension</td>
<td align="left">category</td>
<td align="left">DATA</td>
<td align="left"></td>
<td align="left">Category</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">dimension</td>
<td align="left">procedure</td>
<td align="left">DATA</td>
<td align="left"></td>
<td align="left">Statistical procedure</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">dimension</td>
<td align="left">factor</td>
<td align="left">DATA</td>
<td align="left"></td>
<td align="left">Type of procedure</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">unit</td>
<td align="left">attribute</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">Result</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">denominator</td>
<td align="left">attribute</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">Unit</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">measure</td>
<td align="left">measure</td>
<td align="left"><NA></td>
<td align="left"></td>
<td align="left">Denominator</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">metadata</td>
<td align="left">domainName</td>
<td align="left"><NA></td>
<td align="left"></td>
<td align="left">EXAMPLE</td>
<td align="left"></td>
</tr>
</tbody></table>

<h2>Create RDF data cube</h2>

<p>The RDF data cube for the data above is created using</p>

<pre><code class="r">outcube&lt;- BuildCubeFromDataFrames(cubeMetadata, obsData )
</code></pre>

<p>This shows a simple use of the BuildCubeFromDataFrames function. 
The warning message from log4j can be ignored.</p>

<p>The RDF data cube is serialized in turtle format and stored as a text file in</p>

<pre><code class="r">cat(normalizePath(outcube),&quot;\n&quot;)
</code></pre>

<pre><code>## /tmp/RtmpJjkZMF/DC-EXAMPLE-R-V-0-0-0.ttl
</code></pre>

<h1>Query the cube using SPARQL</h1>

<p>Now take a look at the generated cubes by loading the turle file.</p>

<pre><code class="r">dataCubeFile&lt;- outcube
</code></pre>

<p>The rest of the code only depends on the value of dataCubeFile.
The code demonstrates the use of the rrdf library.</p>

<pre><code class="r">cube &lt;- new.rdf()  # Initialize
load.rdf(dataCubeFile, format=&quot;TURTLE&quot;, appendTo= cube)
summarize.rdf(cube)
</code></pre>

<pre><code>## [1] &quot;Number of triples: 214&quot;
</code></pre>

<p>The next statements are needed for the current implementation of the cube, and may change in future versions.</p>

<pre><code class="r">## TODO: reconsider the use of domain specific prefixes
dsdName&lt;- GetDsdNameFromCube( cube )
domainName&lt;- GetDomainNameFromCube( cube )
cat(&quot;dsdName &quot;, dsdName, &quot;, domainName &quot;, domainName, &quot;\n&quot; )
</code></pre>

<pre><code>## dsdName  dsd-EXAMPLE , domainName  EXAMPLE
</code></pre>

<pre><code class="r">forsparqlprefix&lt;- GetForSparqlPrefix( domainName )
cat(forsparqlprefix,&quot;\n&quot;)
</code></pre>

<pre><code>## prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
## prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;
## prefix prov: &lt;http://www.w3.org/ns/prov#&gt;
## prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
## prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt;
## prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt;
## prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
## prefix qb: &lt;http://purl.org/linked-data/cube#&gt;
## prefix pav: &lt;http://purl.org/pav&gt;
## prefix dct: &lt;http://purl.org/dc/terms/&gt;
## prefix mms: &lt;http://rdf.cdisc.org/mms#&gt;
## prefix cts: &lt;http://rdf.cdisc.org/ct/schema#&gt;
## prefix rrdfqbcrnd0: &lt;http://www.example.org/rrdfqbcrnd0/&gt;
## prefix code: &lt;http://www.example.org/dc/code/&gt;
## prefix dccs: &lt;http://www.example.org/dc/example/dccs/&gt;
## prefix ds: &lt;http://www.example.org/dc/example/ds/&gt;
## prefix crnd-dimension: &lt;http://www.example.org/dc/dimension#&gt;
## prefix crnd-attribute: &lt;http://www.example.org/dc/attribute#&gt;
## prefix crnd-measure: &lt;http://www.example.org/dc/measure#&gt;
## 
</code></pre>

<p>The variable forsparqlprefix contains the prefix statements applicable
for the present data cube. The use of prefixes makes the SPARQL query
shorter, and more readable. The present version of the package defines
namespaces dccs: and ds: where the domainname is included.
TODO: Consider other approach for including the domainname, or use other concept.</p>

<p>The next statement shows the first 10 triples in the cube. This will
most often not be of interest, as the RDF cube contain general
definition and not the specific cube triples.</p>

<table><thead>
<tr>
<th align="left">s</th>
<th align="left">p</th>
<th align="left">o</th>
</tr>
</thead><tbody>
<tr>
<td align="left">rdf:rest</td>
<td align="left">rdf:type</td>
<td align="left">rdf:Property</td>
</tr>
<tr>
<td align="left">rdf:rest</td>
<td align="left">rdfs:domain</td>
<td align="left">rdf:List</td>
</tr>
<tr>
<td align="left">rdf:rest</td>
<td align="left">rdfs:range</td>
<td align="left">rdf:List</td>
</tr>
<tr>
<td align="left">rdf:rest</td>
<td align="left">rdfs:subPropertyOf</td>
<td align="left">rdf:rest</td>
</tr>
<tr>
<td align="left">rdf:List</td>
<td align="left">rdf:type</td>
<td align="left">rdfs:Class</td>
</tr>
<tr>
<td align="left">rdf:List</td>
<td align="left">rdfs:subClassOf</td>
<td align="left">rdfs:Resource</td>
</tr>
<tr>
<td align="left">code:Category</td>
<td align="left">rdfs:subClassOf</td>
<td align="left">rdfs:Resource</td>
</tr>
<tr>
<td align="left">rdf:predicate</td>
<td align="left">rdf:type</td>
<td align="left">rdf:Property</td>
</tr>
<tr>
<td align="left">rdf:predicate</td>
<td align="left">rdfs:domain</td>
<td align="left">rdf:Statement</td>
</tr>
<tr>
<td align="left">rdf:predicate</td>
<td align="left">rdfs:subPropertyOf</td>
<td align="left">rdf:predicate</td>
</tr>
</tbody></table>

<p>The next statement gets the first 30 triples in the cube where 
the subject is a qb:Observation, and shows the first 15 triples.</p>

<pre><code class="r">cube.observations2.rq&lt;-  paste( forsparqlprefix,
&#39;
select *
where { ?s a qb:Observation ; ?p ?o .}
limit 30
&#39;,
&quot;\n&quot;                               
)

cube.observations2&lt;- sparql.rdf(cube, cube.observations2.rq)
knitr::kable(head(cube.observations2, 15))
</code></pre>

<table><thead>
<tr>
<th align="left">s</th>
<th align="left">p</th>
<th align="left">o</th>
</tr>
</thead><tbody>
<tr>
<td align="left">ds:obs1</td>
<td align="left">crnd-measure:measure</td>
<td align="left">123</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">crnd-dimension:procedure</td>
<td align="left">code:procedure-count</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">crnd-dimension:factor</td>
<td align="left">code:factor-quantity</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">crnd-dimension:category</td>
<td align="left">code:category-AA-group</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">qb:dataSet</td>
<td align="left">ds:dataset-EXAMPLE</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">rdfs:label</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">ds:obs1</td>
<td align="left">rdf:type</td>
<td align="left">qb:Observation</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">crnd-measure:measure</td>
<td align="left">456</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">crnd-dimension:procedure</td>
<td align="left">code:procedure-count</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">crnd-dimension:factor</td>
<td align="left">code:factor-quantity</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">crnd-dimension:category</td>
<td align="left">code:category-BB-group</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">qb:dataSet</td>
<td align="left">ds:dataset-EXAMPLE</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">rdfs:label</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">ds:obs2</td>
<td align="left">rdf:type</td>
<td align="left">qb:Observation</td>
</tr>
</tbody></table>

<p>The SPARQL query for codelists are shown in the next output.</p>

<pre><code>## prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
## prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;
## prefix prov: &lt;http://www.w3.org/ns/prov#&gt;
## prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
## prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt;
## prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt;
## prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
## prefix qb: &lt;http://purl.org/linked-data/cube#&gt;
## prefix pav: &lt;http://purl.org/pav&gt;
## prefix dct: &lt;http://purl.org/dc/terms/&gt;
## prefix mms: &lt;http://rdf.cdisc.org/mms#&gt;
## prefix cts: &lt;http://rdf.cdisc.org/ct/schema#&gt;
## prefix rrdfqbcrnd0: &lt;http://www.example.org/rrdfqbcrnd0/&gt;
## prefix code: &lt;http://www.example.org/dc/code/&gt;
## prefix dccs: &lt;http://www.example.org/dc/example/dccs/&gt;
## prefix ds: &lt;http://www.example.org/dc/example/ds/&gt;
## prefix crnd-dimension: &lt;http://www.example.org/dc/dimension#&gt;
## prefix crnd-attribute: &lt;http://www.example.org/dc/attribute#&gt;
## prefix crnd-measure: &lt;http://www.example.org/dc/measure#&gt;
##  
## select distinct ?p ?vn ?cl ?prefLabel 
## where {
## ?DataStructureDefinition a qb:DataStructureDefinition ;
##    qb:component ?component .
## ?component a qb:ComponentSpecification .
## ?component qb:dimension ?p .
## ?p qb:codeList ?c .
## ?c skos:hasTopConcept ?cl .
## ?cl skos:prefLabel ?prefLabel .
## OPTIONAL { ?c rrdfqbcrnd0:R-columnname ?vn } 
## values ( ?DataStructureDefinition ) {
##  (ds:dsd-EXAMPLE) 
## }
## }
## order by ?p ?cl ?prefLabel
</code></pre>

<p>Executing the SPARQL query gives the code list as a data frame.</p>

<pre><code>##          vn                clc prefLabel
## 1  category  category-AA-group  AA-group
## 2  category  category-BB-group  BB-group
## 3  category     category-_ALL_     _ALL_
## 4  category category-_NONMISS_ _NONMISS_
## 5    factor       factor-_ALL_     _ALL_
## 6    factor   factor-_NONMISS_ _NONMISS_
## 7    factor    factor-quantity  quantity
## 8 procedure    procedure-count     count
</code></pre>

<table><thead>
<tr>
<th align="left">vn</th>
<th align="left">clc</th>
<th align="left">prefLabel</th>
</tr>
</thead><tbody>
<tr>
<td align="left">category</td>
<td align="left">category-AA-group</td>
<td align="left">AA-group</td>
</tr>
<tr>
<td align="left">category</td>
<td align="left">category-BB-group</td>
<td align="left">BB-group</td>
</tr>
<tr>
<td align="left">category</td>
<td align="left">category-<em>ALL</em></td>
<td align="left"><em>ALL</em></td>
</tr>
<tr>
<td align="left">category</td>
<td align="left">category-<em>NONMISS</em></td>
<td align="left"><em>NONMISS</em></td>
</tr>
<tr>
<td align="left">factor</td>
<td align="left">factor-<em>ALL</em></td>
<td align="left"><em>ALL</em></td>
</tr>
<tr>
<td align="left">factor</td>
<td align="left">factor-<em>NONMISS</em></td>
<td align="left"><em>NONMISS</em></td>
</tr>
<tr>
<td align="left">factor</td>
<td align="left">factor-quantity</td>
<td align="left">quantity</td>
</tr>
<tr>
<td align="left">procedure</td>
<td align="left">procedure-count</td>
<td align="left">count</td>
</tr>
</tbody></table>

<p>The dimensions are shown in the next output.</p>

<pre><code class="r">cube.dimensions.rq&lt;- paste(forsparqlprefix,
&#39;
select * where
{ [] qb:dimension ?p .  }
&#39;,
&quot;\n&quot;
)
cube.dimensions&lt;- as.data.frame(sparql.rdf(cube, cube.dimensions.rq), stringsAsFactors=FALSE)
knitr::kable(print(cube.dimensions))
</code></pre>

<pre><code>##                          p
## 1    crnd-dimension:factor
## 2 crnd-dimension:procedure
## 3  crnd-dimension:category
</code></pre>

<table><thead>
<tr>
<th align="left">p</th>
</tr>
</thead><tbody>
<tr>
<td align="left">crnd-dimension:factor</td>
</tr>
<tr>
<td align="left">crnd-dimension:procedure</td>
</tr>
<tr>
<td align="left">crnd-dimension:category</td>
</tr>
</tbody></table>

<p>And finally the SPARQL query for observations.</p>

<p>This is the query for getting the observations</p>

<pre><code class="r">cat(cube.observations.rq)
</code></pre>

<pre><code>## prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
## prefix skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;
## prefix prov: &lt;http://www.w3.org/ns/prov#&gt;
## prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
## prefix dcat: &lt;http://www.w3.org/ns/dcat#&gt;
## prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt;
## prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
## prefix qb: &lt;http://purl.org/linked-data/cube#&gt;
## prefix pav: &lt;http://purl.org/pav&gt;
## prefix dct: &lt;http://purl.org/dc/terms/&gt;
## prefix mms: &lt;http://rdf.cdisc.org/mms#&gt;
## prefix cts: &lt;http://rdf.cdisc.org/ct/schema#&gt;
## prefix rrdfqbcrnd0: &lt;http://www.example.org/rrdfqbcrnd0/&gt;
## prefix code: &lt;http://www.example.org/dc/code/&gt;
## prefix dccs: &lt;http://www.example.org/dc/example/dccs/&gt;
## prefix ds: &lt;http://www.example.org/dc/example/ds/&gt;
## prefix crnd-dimension: &lt;http://www.example.org/dc/dimension#&gt;
## prefix crnd-attribute: &lt;http://www.example.org/dc/attribute#&gt;
## prefix crnd-measure: &lt;http://www.example.org/dc/measure#&gt;
## 
## select * where {
##      ?s a qb:Observation  ;
##      qb:dataSet ds:dataset-EXAMPLE  ;
##      crnd-dimension:factor ?factor;
##      crnd-dimension:procedure ?procedure;
##      crnd-dimension:category ?category;
##      crnd-measure:measure      ?measure ;
##      optional{ ?factor skos:prefLabel ?factorvalue . }
##      optional{ ?procedure skos:prefLabel ?procedurevalue . }
##      optional{ ?category skos:prefLabel ?categoryvalue . }
## }
</code></pre>

<p>And finally the observations, which is expected be the same as the starting data set.</p>

<pre><code class="r">cube.observations&lt;- as.data.frame(sparql.rdf(cube, cube.observations.rq ), stringsAsFactors=FALSE)
knitr::kable(cube.observations[,c(paste0(sub(&quot;crnd-dimension:|crnd-attribute:|crnd-measure:&quot;, &quot;&quot;, cube.dimensionsattr), &quot;value&quot;),&quot;measure&quot;)])
</code></pre>

<table><thead>
<tr>
<th align="left">factorvalue</th>
<th align="left">procedurevalue</th>
<th align="left">categoryvalue</th>
<th align="left">measure</th>
</tr>
</thead><tbody>
<tr>
<td align="left">quantity</td>
<td align="left">count</td>
<td align="left">AA-group</td>
<td align="left">123</td>
</tr>
<tr>
<td align="left">quantity</td>
<td align="left">count</td>
<td align="left">BB-group</td>
<td align="left">456</td>
</tr>
</tbody></table>

<h1>Evaluating RDF data cube integrity constraints</h1>

<p>The cube conformance with the integrity constraints can be checked
using the RunQbIC function. The integrity checks are SPARQL queries
are stored in the list qbIClist.  The checks uses the RDF data cube
vocabulary. Therefore the RDF model must contain the RDF data cube
vocabulary.</p>

<pre><code class="r">cubeVocabularyFn&lt;- system.file(&quot;extdata/CUBE-standards-rdf&quot;,&quot;cube.ttl&quot;, package=&quot;rrdfqbcrnd0&quot;)
cubeVocabulary&lt;- load.rdf(cubeVocabularyFn,format=&quot;TURTLE&quot;)
cubeData&lt;- combine.rdf( cubeVocabulary, cube)
</code></pre>

<p>Note, this is not very interesting, as the cube is small.
The evaluation of the integrity contraints takes a while.</p>

<pre><code class="r">icres&lt;- RunQbIC( cubeData, forsparqlprefix )
</code></pre>

<pre><code>## Executing IC-1.  Unique DataSet
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-2. Unique DSD
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-3. DSD includes measure
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-4. Dimensions have range
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-5. Concept dimensions have code lists
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-6. Only attributes may be optional
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-7. Slice Keys must be declared
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-8. Slice Keys consistent with DSD
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-9. Unique slice structure
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-10. Slice dimensions complete
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-11. All dimensions required
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-12. No duplicate observations
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-13. Required attributes
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-14. All measures present
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-15. Measure dimension consistent
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-16. Single measure on measure dimension observation
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-17. All measures present in measures dimension cube 
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-18. Consistent data set links
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-19a. Codes from code list
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-19b. Codes from code list
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## IC-20 and IC-21 are currently not implemented
</code></pre>

<pre><code class="r">knitr::kable(icres)
</code></pre>

<table><thead>
<tr>
<th align="left">ictitle</th>
<th align="right">icfail</th>
</tr>
</thead><tbody>
<tr>
<td align="left">IC-1.  Unique DataSet</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-2. Unique DSD</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-3. DSD includes measure</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-4. Dimensions have range</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-5. Concept dimensions have code lists</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-6. Only attributes may be optional</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-7. Slice Keys must be declared</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-8. Slice Keys consistent with DSD</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-9. Unique slice structure</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-10. Slice dimensions complete</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-11. All dimensions required</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-12. No duplicate observations</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-13. Required attributes</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-14. All measures present</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-15. Measure dimension consistent</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-16. Single measure on measure dimension observation</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-17. All measures present in measures dimension cube</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-18. Consistent data set links</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-19a. Codes from code list</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-19b. Codes from code list</td>
<td align="right">0</td>
</tr>
</tbody></table>

<p>Here we remove one of the dimensions from the cube in observationo
ds:obs1. Note: for the remove.triple function the components must be
given as the full qualified URI. The expected result is that IC-11
fails.</p>

<pre><code class="r">remove.triple(cubeData,
  subject=&quot;http://www.example.org/dc/example/ds/obs1&quot;,
  predicate=&quot;http://www.example.org/dc/dimension#category&quot;,
  object=&quot;http://www.example.org/dc/code/category-AA-group&quot;)
icres&lt;- RunQbIC( cubeData, forsparqlprefix )
</code></pre>

<pre><code>## Executing IC-1.  Unique DataSet
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-2. Unique DSD
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-3. DSD includes measure
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-4. Dimensions have range
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-5. Concept dimensions have code lists
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-6. Only attributes may be optional
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-7. Slice Keys must be declared
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-8. Slice Keys consistent with DSD
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-9. Unique slice structure
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-10. Slice dimensions complete
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-11. All dimensions required
##  -- 1 rows returned (0 is pass, &gt;0 fail)
## Executing IC-12. No duplicate observations
##  -- 2 rows returned (0 is pass, &gt;0 fail)
## Executing IC-13. Required attributes
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-14. All measures present
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-15. Measure dimension consistent
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-16. Single measure on measure dimension observation
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-17. All measures present in measures dimension cube 
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-18. Consistent data set links
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-19a. Codes from code list
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## Executing IC-19b. Codes from code list
##  -- 0 rows returned (0 is pass, &gt;0 fail)
## IC-20 and IC-21 are currently not implemented
</code></pre>

<pre><code class="r">knitr::kable(icres)
</code></pre>

<table><thead>
<tr>
<th align="left">ictitle</th>
<th align="right">icfail</th>
</tr>
</thead><tbody>
<tr>
<td align="left">IC-1.  Unique DataSet</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-2. Unique DSD</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-3. DSD includes measure</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-4. Dimensions have range</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-5. Concept dimensions have code lists</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-6. Only attributes may be optional</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-7. Slice Keys must be declared</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-8. Slice Keys consistent with DSD</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-9. Unique slice structure</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-10. Slice dimensions complete</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-11. All dimensions required</td>
<td align="right">1</td>
</tr>
<tr>
<td align="left">IC-12. No duplicate observations</td>
<td align="right">2</td>
</tr>
<tr>
<td align="left">IC-13. Required attributes</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-14. All measures present</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-15. Measure dimension consistent</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-16. Single measure on measure dimension observation</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-17. All measures present in measures dimension cube</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-18. Consistent data set links</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-19a. Codes from code list</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">IC-19b. Codes from code list</td>
<td align="right">0</td>
</tr>
</tbody></table>

<p>IC-12 also fails; examining the SPARQL query shows why.</p>

<pre><code class="r">cat(qbIClist[[&quot;ic-12&quot;]]$rq,&quot;\n&quot;)
</code></pre>

<pre><code>## ASK {
##   FILTER( ?allEqual )
##   {
##     # For each pair of observations test if all the dimension values are the same
##     SELECT (MIN(?equal) AS ?allEqual) WHERE {
##         ?obs1 qb:dataSet ?dataset .
##         ?obs2 qb:dataSet ?dataset .
##         FILTER (?obs1 != ?obs2)
##         ?dataset qb:structure/qb:component/qb:componentProperty ?dim .
##         ?dim a qb:DimensionProperty .
##         ?obs1 ?dim ?value1 .
##         ?obs2 ?dim ?value2 .
##         BIND( ?value1 = ?value2 AS ?equal)
##     } GROUP BY ?obs1 ?obs2
##   }
## }
## 
</code></pre>

<p>As RRDF does not support the ASK query, the IC queries are changed 
to a SELECT query returning the number of triples selected.</p>

</body>

</html>
