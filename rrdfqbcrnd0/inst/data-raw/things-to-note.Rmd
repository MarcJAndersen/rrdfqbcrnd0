---
title: "Create AE table as csv file"
author: "mja@statgroup.dk"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create AE table as csv file}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

# Code snippets that may be of use.

```{r}
knitr::read_chunk("setup.R")
```
```{r setup}
```

## Comment on earlier setup, delete if not needed.

When developing, the script is intented to run from the package root as
```{r, results='asis', eval=FALSE}
knit("inst/data-raw/create-qb-CDISC-prefix.Rmd")
```

knit runs the script in the data-raw directory, so it would be
expected to use pkg=".." to store the qbIClist in the data directory
However, it did not work - hence the setwd below-

Data are stored in the data directory, following [R packages by Hadley Wickham](http://r-pkgs.had.co.nz/data.html) and [Writing R Extensions](http://cran.r-project.org/doc/manuals/R-exts.pdf).


## Check RRDF works

```r
store<- new.rdf(ontology=FALSE)
add.prefix(store, prefix="dc", namespace="http://www.example.org/")
add.triple(store,"ex:aa","ex:i1","9876")
add.triple(store,"ex:bb","ex:i2","1234")
add.triple(store,"http://www.example.org/aa","ex:i3","24543")
store
sparql.rdf(store, "select * where { ?s ?p ?o }")

```


## SPARQL queries for cube

```{r, eval=FALSE}
forsparqlprefix<-"
prefix prov:  <http://www.w3.org/ns/prov#>
prefix mms:   <http://rdf.cdisc.org/mms#>
prefix crnd-dimension:	<http://www.example.org/dc/dimension#>
prefix crnd-attribute:	<http://www.example.org/dc/attribute#>
prefix crnd-measure:	<http://www.example.org/dc/measure#>
prefix code:  <http://www.example.org/dc/code/>
prefix qb:    <http://purl.org/linked-data/cube#>
prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#>
prefix dccs:  <http://www.example.org/dc/demo/dccs/>
prefix dcat:  <http://www.w3.org/ns/dcat#>
prefix pav:   <http://purl.org/pav>
prefix dct:   <http://purl.org/dc/terms/>
prefix xsd:   <http://www.w3.org/2001/XMLSchema#>
prefix owl:   <http://www.w3.org/2002/07/owl#>
prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix cts:   <http://rdf.cdisc.org/ct/schema#>
prefix skos:  <http://www.w3.org/2004/02/skos/core#>
prefix rrdfqbcrnd0: <http://www.example.org/rrdfqbcrnd0/>
prefix ds:    <http://www.example.org/dc/demo/ds/>
"

dsdname.rq<- "
select ?s
where {
?s a qb:DataStructureDefinition
} 
"
DataStructureDefinition<- data.frame(sparql.rdf(store, paste( forsparqlprefix, dsdname.rq)), stringsAsFactors=FALSE )
knitr::kable(DataStructureDefinition)

dimensions.rq<- "
select *
where {
?s a qb:DataStructureDefinition .
?s qb:component [ qb:dimension ?qbdimension ] .
OPTIONAL { ?s qb:component [ qb:order ?qborder] . }

} 
"
dimensions<- data.frame(sparql.rdf(store, paste( forsparqlprefix, dimensions.rq)), stringsAsFactors=FALSE )
knitr::kable(dimensions)

rq<-  paste( forsparqlprefix,
'
select ?dsd ?obs ?qborder ?qbdimension ?dimvalue ?dimvalueLabel
where { 
?obs a qb:Observation ; 
?qbdimension ?dimvalue ;
.
{ select * where {
?dsd a qb:DataStructureDefinition .
?dsd qb:component [ qb:dimension ?qbdimension ] .
OPTIONAL {?dsd qb:component [ qb:order ?qborder] .}
} }

OPTIONAL { ?dimvalue skos:prefLabel ?dimvalueLabel}

values (?dsd ?obs) {
(ds:dsd-DEMO ds:obs114)
}
}
order by ?dsd ?obs ?qborder ?qbdimension 
# limit 30
',
"\n"                               
)

cube.observations<- sparql.rdf(store, rq)
knitr::kable(cube.observations)

## Identify which dimensions are used for selection
rq<-  paste( forsparqlprefix,
'
select ?dsd ?obs ?qborder ?qbdimension ?dimvalue ?dimvalueLabel ?subsetting ?factorvalueLabel ?procedurevalue ?procedureLabel ?variable
where { 
?obs a qb:Observation ; 
?qbdimension ?dimvalue ;
.
{ select * where {
?dsd a qb:DataStructureDefinition .
?dsd qb:component [ qb:dimension ?qbdimension ] .
OPTIONAL {?dsd qb:component [ qb:order ?qborder] .}
} }

OPTIONAL { ?obs crnd-dimension:factor ?factorvalue . ?factorvalue skos:prefLabel ?factorvalueLabel }
OPTIONAL { ?obs crnd-dimension:procedure ?procedurevalue . ?procedurevalue skos:prefLabel ?procedureLabel }

OPTIONAL { ?dimvalue skos:prefLabel ?dimvalueLabel}


BIND( (?qbdimension NOT IN (crnd-dimension:procedure, crnd-dimension:factor) &&  ?dimvalueLabel != "_ALL_" ) AS ?subsetting )

BIND( replace(  str(?qbdimension), str(crnd-dimension:), " " )  AS ?variable )

values (?dsd ?obs) {
(ds:dsd-DEMO ds:obs29)
}
}
order by ?dsd ?obs ?qborder ?qbdimension 
# limit 30
',
"\n"                               
)

cube.observations<- data.frame(sparql.rdf(store, rq),stringsAsFactors=FALSE)
knitr::kable(cube.observations)

cat(
paste(
paste( "Variable", cube.observations$factorvalueLabel[1], sep=" ", collapse=""),
paste( "Statistics ", cube.observations$procedureLabel[1], sep=" ", collapse=""),
paste( "Selection criteria ", cube.observations$variable[cube.observations$subsetting=="true"], "=", cube.observations$dimvalueLabel[cube.observations$subsetting=="true"], sep=" ", collapse="\n" ),
"",
sep="\n", collapse="\n")
)

dsname<-"adsl"

## using list for key-value lookup to function for descriptive statistic
univfunc<- list(
  "code:procedure-mean"         =function(x){mean(x,na.rm=TRUE)},
  "code:procedure-stddev"       =function(x){sd(x,na.rm=TRUE)},
  "code:procedure-median"       =function(x){median(x,na.rm=TRUE)},
  "code:procedure-min"          =function(x){min(x,na.rm=TRUE)},
  "code:procedure-max"          =function(x){max(x,na.rm=TRUE)},
  "code:procedure-count"        =length,
  "code:procedure-countdistinct"=function(x){length(unique(x))}
  )

cat(
univfunc[[locase(cube.observations$procedurevalue[1])]], "(", dsname, "$", cube.observations$factorvalueLabel[1],
"[", 
paste(
paste0( dsname, "$", gsub(" *", "", cube.observations$variable[cube.observations$subsetting=="true"]),
"==",
'"',cube.observations$dimvalueLabel[cube.observations$subsetting=="true"], '"',sep=""),
sep=" & ", collapse="\n"),
"]",
")",
sep="", collapse="\n")



paste(
paste( "Variable", cube.observations$factorvalueLabel[1], sep=" ", collapse=""),

paste( "Selection criteria ", cube.observations$variable[cube.observations$subsetting=="true"], "=", cube.observations$dimvalueLabel[cube.observations$subsetting=="true"], sep=" ", collapse="\n" ),
"",
sep="\n", collapse="\n")
)

require(foreign)
xptdirectory<- tempdir()

fnadsl<- system.file("extdata/sample-xpt", "adsl.xpt", package="rrdfqbcrnd0")
adsl<-read.xport(fnadsl)
names(adsl)<- tolower(names(adsl))

min(adsl$weightbl[adsl$trt01a =="Xanomeline High Dose" & adsl$weightbl])

## sprintf("%4.0f", min(adsl$weightbl[adsl$trt01a =="Xanomeline High Dose" & adsl$weightbl]))

```


## Compare results from SQL with the input / previously generated


```{r, eval=FALSE}

colorder<- c( "saffl", "trt01a", "race", "sex", "procedure", "factor", "denominator", "unit", "measure")

# dmtablecompareFile<- system.file("extdata/sample-cfg", "dm-prev.AR.csv", package="rrdfqbcrnd0")
dmtablecompareFile<- system.file("extdata/sample-cfg", "dm.AR.csv", package="rrdfqbcrnd0")

dmtable<- read.csv(dmtablecompareFile,stringsAsFactors=FALSE)
names(dmtable)<-tolower(names(dmtable))
## str(dmtable)
Sort <- function(DF) DF[do.call(order, DF),]
fromCSV.for.all.equal<- Sort(dmtable[,colorder])
## str(adsl.summ.stat)
xadsl.summ.stat<- adsl.summ.stat[,colorder]
fromSQL.for.all.equal<- Sort(xadsl.summ.stat[ , intersect(names(fromCSV.for.all.equal),names(xadsl.summ.stat)) ])
all.equal(fromCSV.for.all.equal, fromSQL.for.all.equal, check.attributes = FALSE)
compare<-merge(fromSQL.for.all.equal, fromCSV.for.all.equal,by=setdiff(colorder,"measure"),all=TRUE)
## simple criteria - should also include relative difference
compare$isequal<- abs(compare$measure.x - compare$measure.y ) < 1e-6
compare

```

## Make graph of dependencies in Makefile

The DAG defined in the Makefile could be usefull to show.
See (http://stackoverflow.com/questions/2376837/creating-a-directed-acyclic-graph-out-of-recursive-nmake-makefile).

Essentailly _make -n -p_ gives the relevant output, which then could be parsed and displayed.

## Writing to other formats

```{r, eval=FALSE}
library(rrdf)
library(rrdfqbcrnd0)
store<- new.rdf()
dataCubeFile<- system.file("extdata/sample-rdf", "DC-DEMO-sample.TTL", package="rrdfqbcrnd0")
print(dataCubeFile)
load.rdf(dataCubeFile, format="TURTLE", appendTo= store)
summarize.rdf(store)

format<-"RDF/JSON"
filename<-"DC-demo.json"
.jcall("com/github/egonw/rrdf/RJenaHelper", "V", "saveRdf", store, filename, format)

## This does not work - maybe due mising jar in rrdf
## Error in .jcall("com/github/egonw/rrdf/RJenaHelper", "V", "saveRdf", store,  :
##  java.lang.NoClassDefFoundError: com/github/jsonldjava/core/JsonLdError
## ttps://jena.apache.org/documentation/io/rdf-output.html
format<-"JSON-LD"
filename<-"DC-demo.json-ld"
.jcall("com/github/egonw/rrdf/RJenaHelper", "V", "saveRdf", store, filename, format)
```


## At the end of each scipt

Add the following - note it should be possible to generate it automatically.


How to compile this file into HTML

Start an R-session in the same directory as the file and issue:
```{r, eval=FALSE}
library(knitr)
knit2html("XX.Rmd")
```
Alternatively, use invoke R from the command line with parameters for executing knit2html.
