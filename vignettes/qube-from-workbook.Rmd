---
title: "Data qubes from Workbook"
author: "PhuseSubTeamAnalysisResults@example.org"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data qubes from Workbookle}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---


### How to run from command prompt when developing

Start in the package root directory

Devtools should reply reply Loading rrdfqbcrnd0.

The knit command should generate .md file in the present work directory - the package root directory


```{r, eval=FALSE}
library(devtools)
devtools::load_all()

library(knitr)
knit("vignettes/qube-from-workbook.Rmd")
```

Generate the pdf file using the following command
```{r makepdf.sh, eval=FALSE, engine='bash'}
pandoc qube-from-workbook.md -o xx.pdf
```

The knitr::knit2html should generate a .html file in the present work directory - the package root directory

Generating HTML works nicely
```{r, eval=FALSE} 
knitr::knit2html("vignettes/qube-from-workbook.Rmd")
```

The following does not work as the texi2dvi can not handle the dollar signs in the bash code above.
I suppose some other options have to be given. The work around is to use pandoc on the .md file generated as mentioned above.

```{r, eval=FALSE}
knitr::knit2pdf("vignettes/qube-from-workbook.Rmd")
```

## Code


```{r, eval=TRUE}

library (rrdf)
library (xlsx)
library(rrdfqbcrnd0)


#TODO: To pass in as a parameter. Will have values: DM, AE, etc.
#NOTE: Must match the name in the workbook sheet (DM-components), etc.
#      Also used in cube name, dsd-<name>, and other places.

domainName<- "AE"
# domainName<- "DM"

endpoint<- NULL # for using internal rdf.cdisc.org store
RDFCubeWorkbook<- system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")


############
# Prefixes #
###############################################################################
# Construct list to hold the prefix namespaces, 
# using format:prefixPREFIXNAME with key .
# Sources: 1. Workbook sheet CubePrefixes 2. custom built on domain name
# Vars. used  later in the construction of cube skeleton and cube obs.
#   Examples: prefixQB   holds value http://purl.org/linked-data/cube#
#             prefixRDFS holds value http://www.w3.org/2000/01/rdf-schema#


# Prefixes common to all cubes (regardless of domain) 
common.prefixes <- read.xlsx(RDFCubeWorkbook,sheetName=paste0("CubePrefixes"))

# Domain-specific prefixes:for /code/, /prop/, /dccs/ and /dataset/
custom.prefixes <-Get.qb.crnd.prefixes(tolower(domainName))

prefixes=rbind(common.prefixes, custom.prefixes)                                                


# should maybe get that from some other data - eg. stored in the cube
if (domainName=="DM") {
DM.recode.list<- list(
    "sex"=list( 'F'='sex-F','M'='sex-M', '_ALL_'='sex-_ALL_' ),
    "race"= list('WHITE'='race-WHITE',
                       'BLACK OR AFRICAN AMERICAN'='race-BLACK_OR_AFRICAN_AMERICAN',
                       'AMERICAN INDIAN OR ALASKA NATIVE'='race-AMERICAN_INDIAN_OR_ALASKA_NATIVE',
                       '_ALL_'='race-_ALL_' ),
    "trt01a"=list('Placebo'='trt01a-Placebo',
                  'Xanomeline High Dose'='trt01a-Xanomeline_High_Dose',
                  'Xanomeline Low Dose'='trt01a-Xanomeline_Low_Dose',
                  '_ALL_'='trt01a-_ALL_' ),
    "saffl"=list('Y'='saffl-Y',
                        'N'='saffl-N',
                        '_ALL_'='saffl-_ALL_')
  )
data.recode.list<- DM.recode.list  
}

if (domainName=="AE") {

  AE.recode.aedecod.list<- read.csv(file=system.file("extdata/sample-cfg", "ae.aedecod.AR.csv", package="rrdfqbcrnd0"))
aedecod.list= list();
for (i in 1:nrow(AE.recode.aedecod.list)) {
  aedecod.list[[ as.character(AE.recode.aedecod.list[i,1]) ]]= encodetouri( paste0("aedecod-",as.character(AE.recode.aedecod.list[i,2])) )
}

AE.recode.list= list(
    "saffl"=list('Y'='saffl-Y',
                        'N'='saffl-N',
                        '_ALL_'='saffl-_ALL_'),
    "trta"=list('Placebo'='trta-Placebo',
                         'Xanomeline High Dose'='trta-Xanomeline_High_Dose',
                         'Xanomeline Low Dose'='trta-Xanomeline_Low_Dose',
                         '_ALL_'='trta-_ALL_' ),
    "aesoc"=aesoc.list,
    "aedecod"=aedecod.list,
    "factor"=list('quantity'='factor-QUANTITY',
                         'proportion'='factor-PROPORTION', 
                         'AGE'='factor-AGE',
      'USUBJID'='factor-USUBJID'
      )
  )

data.recode.list<- AE.recode.list  
}


qb.crnd.recode.list<- list(
    "factor"=list('quantity'='factor-QUANTITY',
                         'proportion'='factor-PROPORTION', 
                         'AGE'='factor-AGE' ),
    "procedure"= list('count'='procedure-COUNT',
                      'countdistinct'='procedure-COUNTDISTINCT',
                      'percent'='procedure-PERCENT', 
                      'mean'='procedure-MEAN', 
                      'stdev'='procedure-STDDEV', 
                      'min'='procedure-MIN', 
                      'median'='procedure-MEDIAN', 
                      'max'='procedure-MAX' )                        
     );

recode.list<- c( data.recode.list, qb.crnd.recode.list)

  procedure2format= list("count"="int",
                         "countdistinct"="int",
                            'percent'='double', 
                            'mean'='double', 
                            'stdev'='double', 
                            'min'='double', 
                            'median'='double', 
                            'max'='double'                         
     );

  
store <- new.rdf(ontology=FALSE)  # Initialize

# Register prefixes
prefixlist<- qb.def.prefixlist(store, prefixes)

###############################################################################
# Read the skeleton  specifications to dataframe
# Source workbook: compType, compName, compLabel
# TODO: Replace some use of compLabel with a var : compNameClass, formed by
#       Upcase of first letter of the compName value.
cubeMetadata <- read.xlsx(RDFCubeWorkbook,sheetName=paste0(domainName,"-Components"))

metadataSource <-cubeMetadata[grep("metadata", cubeMetadata$compType),]


# Cube metadata. 
cubeDescription <- as.character(cubeMetadata[grep("description", cubeMetadata$compName), "compLabel" ])
cubeComment<- as.character(cubeMetadata[grep("comment", cubeMetadata$compName), "compLabel" ])
cubeLabel<-as.character(cubeMetadata[grep("label", cubeMetadata$compName), "compLabel" ])
cubeTitle<-as.character(cubeMetadata[grep("title", cubeMetadata$compName),"compLabel" ])
# Output file format: DC-<domain>-R-Vn-n-(n).TTL . Also used in dcat:distribution
# NOTE: For pav:Version (dot, notdash) and output file name
cubeVersion <- gsub("\\.","-",metadataSource[ metadataSource$compName=="cubeVersion", "compLabel" ])


if (any(metadataSource$compName=="dataCubeOutDirectory")) {
dataCubeOutDirectory<- as.character(metadataSource[ metadataSource$compName=="dataCubeOutDirectory", "compLabel" ])
} else  {dataCubeOutDirectory<-""}

if (nchar(dataCubeOutDirectory)==0 | dataCubeOutDirectory=="!temporary" ) {
dataCubeOutDirectory<- tempdir()
}
  
dataCubeFileName  <- paste0("DC-", domainName,"-R-V-",cubeVersion,".TTL")   
dataCubeFile      <- file.path(dataCubeOutDirectory,dataCubeFileName) # Full path to cube

# Get the analysis results - which will be the Cube Observation data       

if (any(metadataSource$compName=="obsFileNameDirectory")) {
obsFileDir<- as.character(metadataSource[ metadataSource$compName=="obsFileNameDirectory", "compLabel" ])
} else  {obsFileDir<-""}

if (nchar(obsFileDir)==0 | obsFileDir=="!example" ) {
obsFileDir<- system.file("extdata/sample-cfg", package="rrdfqbcrnd0")
}

obsFile<- as.character(metadataSource[ metadataSource$compName=="obsFileName", "compLabel" ])
obsData <- read.csv(file.path(obsFileDir,obsFile))
# Making variable names to lower case
names(obsData)<- tolower(names(obsData))

# Subset to the dimensions, attributes, and measure used to construct the skeleton
skeletonSource <-cubeMetadata[grep("dimension|attribute|measure", cubeMetadata$compType),]

qb.buildSkeleton(store, prefixlist, obsData, skeletonSource)

# Issue How to handle multiple terminlogy files for code list generation?
qb.buildDSD(store, prefixlist, obsData, skeletonSource,
            dsdURIwoprefix=paste0("dataset-",domainName),
            dsdName=paste0("dsd-",domainName),
            extra=list(description=cubeDescription,
              comment=cubeComment,
              label=cubeLabel,
              distribution=dataCubeFileName,
              obsfilename=obsFile,
              title=cubeTitle
               ),
remote.endpoint=endpoint
#            codelist.source=sdtm.terminology
          )

qb.buildObservations(
  store=store,
  prefixlist=prefixlist,
  obsData=obsData,
  skeletonSource=skeletonSource,
  dsdURIwoprefix=paste0("dataset-", domainName),
  recode.list=recode.list,
  procedure2format=procedure2format
  )

# Output 
outcube <- save.rdf(store, filename=dataCubeFile, format="TURTLE")

```


Now look at the cube. Note: by specifying prefix the output contains is shown using the prefixes.
Note for future: This may be a disadvantage if the value of the prefix, say ds, changes.

```{r, echo=FALSE, results='asis'}

domainName<- "AE"
checkCube <- new.rdf(ontology=FALSE)  # Initialize
load.rdf(dataCubeFile, format="TURTLE", appendTo= checkCube)
summarize.rdf(checkCube)


## ------------------------------------------------------------------------

data(qbCDISCprefixes)
common.prefixes <- data.frame(
    prefix=gsub("^prefix","",names(qbCDISCprefixes)),
    namespace=as.character(qbCDISCprefixes )
    )
custom.prefixes <-Get.qb.crnd.prefixes(tolower(domainName))

forsparqlprefix<- Get.rq.prefix.df(rbind(common.prefixes, custom.prefixes))

cube.observations1.rq<-    paste( forsparqlprefix,
     "select * where {?s ?p ?o .} limit 10",
     "\n"
     )

cube.observations1<- sparql.rdf(checkCube, cube.observations1.rq  )
knitr::kable(head(cube.observations1, 10))

cube.observations2.rq<-  paste( forsparqlprefix,
     "select * where { ?s a qb:Observation ; ?p ?o .}",
     "\n"                               
   )

cube.observations2<- sparql.rdf(checkCube, cube.observations2.rq)
knitr::kable(head(cube.observations2, 10))

```
