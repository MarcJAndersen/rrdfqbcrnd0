---
title: "Derive results in RDF data cube and compare with results in data cube"
author: "mja@statgroup.dk"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Derive results in RDF data cube and compare with results in data cube}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

### Developing
Use
```{r eval=FALSE}
library(knitr)
knit("vignettes/check-cube.Rmd")
``` 

```{r, results='asis', eval=TRUE}

library(foreign)
library(RCurl)

library(rrdf)
library(rrdfqbcrnd0)


check.cube<- function(
  fnxptDataSet=paste(tempdir(),"/", "adsl", ".xpt",sep=""),
  dsURL= "https://phuse-scripts.googlecode.com/svn/trunk/scriptathon2014/data/adsl.xpt",
  ds.dataset= "ds:dataset-demog",
  qbfile= system.file("extdata/sample-rdf", "DC-DM-sample.TTL", package="rrdfqbcrnd0"),
  domainName="demog"
#  fnxptDataSet=paste(tempdir(),"/", "adae", ".xpt",sep=""),
#  dsURL= "https://phuse-scripts.googlecode.com/svn/trunk/scriptathon2014/data/adae.xpt",
#  ds.dataset= "ds:dataset-ae",
#  qbfile= system.file("extdata/sample-rdf", "DC-AE-sample.TTL", package="rrdfqbcrnd0")
#  domainName="ae"
  
) {


if (! is.null(dsURL) ) {
   if (! url.exists(dsURL) ) {
      stop(paste0("Can not access URL ",dsURL))
   }
   download.file( dsURL, fnxptDataSet, method="curl")
}

DataSet=read.xport(fnxptDataSet)

## library(Hmisc)
## DataSet <- sasxport.get(fnDataSet)
## # --- see what have got:
## contents(DataSet)
## label(DataSet)

# str(DataSet)


cubeData = new.rdf(ontology=FALSE)

data(qbCDISCprefixes)

RDFCubeWorkbook = system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")
common.prefixes = read.xlsx(RDFCubeWorkbook,sheetName=paste0("CubePrefixes"))
# Domain-specific prefixes:for /prop/, /dccs/ and /dataset/
custom.prefixes <-data.frame(prefix=c("prop", "dccs", "ds"),
        namespace=c(paste0("http://www.example.org/dc/",domainName,"/prop/"),
                    paste0("http://www.example.org/dc/",domainName,"/dccs/"),
                    paste0("http://www.example.org/dc/",domainName,"/dataset/")
                    ))
# Prefix for doing the check of the data cube
check.prefix<- data.frame(prefix=c("valid"),
        namespace=c(paste0("http://www.example.org/dc/",domainName,"/valid/")
                            ))

prefixes<- rbind(common.prefixes, custom.prefixes, check.prefix)

# print(prefixes)


forsparqlprefix<- paste("prefix", paste(prefixes$prefix,":",sep=""), paste("<",prefixes$namespace,">",sep=""),sep=" ",collapse="\n")

load.rdf( qbfile, format="N3", appendTo= cubeData)
# summarize.rdf(cubeData)


## ------------------------------------------------------------------------
cube.observations1<- sparql.rdf(cubeData,
   paste( forsparqlprefix,
     "select * where {?s ?p ?o .} limit 10"
     )
   );
print(   paste( forsparqlprefix,
     "select * where {?s ?p ?o .} limit 10"
     )
)
# print(cube.observations1)


cube.observations2<- sparql.rdf(cubeData,
   paste( forsparqlprefix,
     "select * where { ?s a qb:Observation ; ?p ?o .} limit 10"
     )
   );
# print(cube.observations2)

## get the dimensions
cube.dimensions= sparql.rdf(cubeData,
  paste(forsparqlprefix,
"select * where { [] qb:dimension ?p .  }"
));
# print(cube.dimensions)

## prop:trt01a  a       rdf:Property , qb:DimensionProperty ;
##         rdfs:label   "Treatment Arm" ;
##         rdfs:range   code:Trt01a ;
##         qb:codeList  code:trt01a .



# this will be made generic based on the dimensions in the cube
## subsetting.dimensions<- list(
##   "saffl"="code:saffl-_ALL_",
##   "trt01a"="code:trt01a-_ALL_",
##   "race"="code:race-_ALL_",
##   "sex"="code:sex-_ALL_"
##   )


## get the codelist
cube.codelists= as.data.frame(sparql.rdf(cubeData,
  paste(forsparqlprefix,
'
select ?p ?cl ?prefLabel where {
[] qb:dimension ?p.
?p qb:codeList ?c.
?c skos:hasTopConcept ?cl .
?cl skos:prefLabel ?prefLabel.
}
'
)));
# print(cube.codelists)


codelist.all<- cube.codelists[ cube.codelists$prefLabel=="_ALL_",]
# print(codelist.all)
subsetting.dimensions<- list();

# the variable name/column name in the data frame should be part of the datacube
# this would remove the need for the workaround below using gsub
for (i in 1:nrow(codelist.all))
{
  subsetting.dimensions[[ gsub("[^:]*:","", codelist.all[i,"p"]) ]] <-
      as.character(codelist.all[i,"cl"])
}


## get the dimensions and attributes

cube.dimensionsattr<- sparql.rdf(cubeData,
  paste(forsparqlprefix,
"select * where { {[] qb:dimension ?p . } union {  ?p a qb:AttributeProperty . } }"
));
# print(cube.dimensionsattr)

selectexpr=  paste(  "select * where {",
    "    ?s a qb:Observation  ;",
    paste("       qb:dataSet",  ds.dataset, " ;", sep=" ", collapse=" "),
    paste0( cube.dimensionsattr, " ", sub("prop:", "?", cube.dimensionsattr), ";",sep=" ",collapse=" "),
    "       prop:measure      ?measure ;      ",
    "       prop:denominator      ?denominator .      ",
    paste0( "optional{ ", sub("prop:", "?", cube.dimensionsattr), " ",
           "skos:prefLabel",
           " ",
           sub("prop:", "?", cube.dimensionsattr), "value" ,
           " . ", "}",
           sep=" ",collapse="\n"),
    "} " );
# print(selectexpr)
# print(  paste(forsparqlprefix, selectexpr ) )

cube.observations<- sparql.rdf(cubeData,
  paste(forsparqlprefix, selectexpr )
  );

# print(head(cube.observations))
# str(cube.observations)

# cts:cdiscSubmissionValue could also be used instead of skos:prefLabel
# by code:saffl-Y does not have cts:cdiscSubmissionValue

# using list for key-value lookup to function for descriptive statistic
univfunc1= list(
  "code:procedure-MEAN"=mean,
  "code:procedure-STDDEV"=sd,
  "code:procedure-MEDIAN"=median,
  "code:procedure-MIN"=min,
  "code:procedure-MAX"=max
  )

univfunc2= list(
  "code:procedure-COUNT"=length,
  "code:procedure-COUNTDISTINCT"=function(x){length(unique(x))}
  )


for (r in  1: nrow(cube.observations )  ) {
thisrow<-  cube.observations[r,]
# print(thisrow)

data.subset.logical= rep(TRUE, nrow(DataSet))
for (v in names(subsetting.dimensions)) {
  # print( c(v, thisrow[v ],  subsetting.dimensions[[ v ]] ) )
  if ( thisrow[v ] != subsetting.dimensions[[ v ]] ) {
  # print( paste0(v, ": ", thisrow[v ], " = ", thisrow[ paste0(v,"value") ]))
  # print( DataSet[,toupper(v)] == thisrow[ paste0(v,"value") ] )
    data.subset.logical= data.subset.logical & ( DataSet[,toupper(v)] == thisrow[ paste0(v,"value") ] )
  }
}


has.result= FALSE

if (thisrow["procedure"] %in% names(univfunc1) ) {
# print("univfunc1")
  AOD= DataSet[data.subset.logical,thisrow["factorvalue"]]
  result= univfunc1[[ thisrow["procedure"] ]](AOD)
  has.result= TRUE
#   print(paste("AOD number of observations", nrow(AOD)))
} else if (thisrow["procedure"] %in% names(univfunc2) ) {
# print(paste0("univfunc2"," ",thisrow["procedure" ],collapse=" "))
  AOD= DataSet[data.subset.logical,"USUBJID"]  # take the first variable, would be better if there was a default, like USUBJID
  result= univfunc2[[ thisrow["procedure" ] ]](AOD)
  has.result= TRUE
#   print(paste0("AOD number of observations", nrow(AOD), sep=" "))
} else if (thisrow["procedure"]== "code:procedure-PERCENT" & thisrow["factor"]== "code:factor-PROPORTION") {

#  print(c("proportion",thisrow["denominator"]))

#  denom.def<- thisrow[ c("saffl", "trt01a", "race", "sex" ) ]
#  denom.def<- thisrow[ c( "trt01a", "race", "sex" ) ]
  denom.def<- thisrow[ names(subsetting.dimensions) ]
  
  denom.def[ tolower(thisrow["denominator"]) ] =paste0("code:",tolower(thisrow["denominator"]),"-_ALL_",sep="")
  AOD= DataSet[data.subset.logical,] # should use a variable name - USUBJID like for count

denom.data.subset.logical= rep(TRUE, nrow(DataSet))
# print( denom.def )
for (v in names(denom.def)) {
  if ( denom.def[v ] != subsetting.dimensions[[ v ]] ) {
    denom.data.subset.logical= denom.data.subset.logical & ( DataSet[,toupper(v)] == thisrow[ paste0(v,"value") ] )
  }
}
  denom.data.frame<-  DataSet[denom.data.subset.logical , ]

  result= nrow(AOD) / nrow( denom.data.frame ) * 100;
  has.result=TRUE
  # print(paste("AOD number of observations", nrow(AOD)))
  # print(paste("denom.data.frame number of observations", nrow(denom.data.frame)))
}


# print( gsub("ds:", myprefixes$ds, thisrow["s"]) )
# print( gsub("valid:", myprefixes$valid, "valid:result") )
# print( paste(result) )

if (has.result) {
# print(paste0("result", result, sep=" "))
add.data.triple( cubeData,
subject=gsub("ds:", myprefixes$ds, thisrow["s"]), # add triple does not resolve prefix
predicate=gsub("valid:", myprefixes$valid, "valid:result"),
data=paste(result), type="float")
} else {
#  print( paste( thisrow["s"], ifelse(has.result, result, "No result determined") ) )
}


} # for
cube.check= sparql.rdf(cubeData,
  paste(forsparqlprefix,
    "select * where {",
    "    ?s a qb:Observation  ;",
    paste("       qb:dataSet",  ds.dataset, " ;", sep=" ", collapse=" "),
#    "       prop:saffl        ?saffl ;        ",
#    "       prop:trt01a       ?trt01a ;       ",
#    "       prop:race         ?race ;         ",
#    "       prop:sex          ?sex ;          ",
#    "       prop:procedure    code:procedure-PERCENT ;",
#    "       prop:procedure    ?procedure ;    ",
#    "       prop:denominator  ?denominator ;",
#    "       prop:factor       ?factor ;       ",
    "       prop:measure      ?measure ;      ",
    "      optional{ ?s valid:result      ?result }      ",
    " filter ( ?measure != ?result ) ",
    "} order by ?s"
                )
  );

print("If the result is <0 x 0> matrix then all value matches")
cube.check


}



check.cube(
   fnxptDataSet=paste(tempdir(),"/", "adsl", ".xpt",sep=""),
   dsURL= "https://phuse-scripts.googlecode.com/svn/trunk/scriptathon2014/data/adsl.xpt",
   ds.dataset= "ds:dataset-demog",
 qbfile= system.file("extdata/sample-rdf", "DC-DM-sample.TTL", package="rrdfqbcrnd0"),
 domain="demog"
 )

 check.cube(
 fnxptDataSet=paste(tempdir(),"/", "adae", ".xpt",sep=""),
 dsURL= "https://phuse-scripts.googlecode.com/svn/trunk/scriptathon2014/data/adae.xpt",
 ds.dataset= "ds:dataset-ae",
 qbfile= system.file("extdata/sample-rdf", "DC-AE-sample.TTL", package="rrdfqbcrnd0"),
 domain="ae"
 )

check.cube(
  fnxptDataSet=paste(tempdir(),"/", "adsl", ".xpt",sep=""),
  dsURL= NULL,
  ds.dataset= "ds:dataset-demog",
qbfile= system.file("extdata/sample-rdf", "DC-DM-sample.TTL", package="rrdfqbcrnd0"),
domain="demog"
)

check.cube(
fnxptDataSet=paste(tempdir(),"/", "adae", ".xpt",sep=""),
dsURL=  NULL,
ds.dataset= "ds:dataset-ae",
qbfile= system.file("extdata/sample-rdf", "DC-AE-sample.TTL", package="rrdfqbcrnd0"),
domain="ae"
)


```

