---
title: "Data qubes from Workbook"
author: "PhuseSubTeamAnalysisResults@example.org"
date: "`r Sys.Date()`"
output: 
   rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data qubes from Workbook}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

# Setup

First load the package.
```{r, eval=TRUE}
library(rrdfqbcrnd0)
```

# Generating RDF data cube from specification in a spreadsheet and export as turtle file

The generation of RDF data cube can be specified in a spreadsheet.
The outputs below shows the meta data for generation of the DM RDF data cube.

```{r, eval=TRUE}
RDFCubeWorkbook<- system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")
cubeMetadata <- read.xlsx(RDFCubeWorkbook,
                          sheetName=paste0("DM-Components"),
                          stringsAsFactors=FALSE)
knitr::kable(
  cubeMetadata[ cubeMetadata$compType %in% c("dimension", "attribute", "measure"),
               c("codeType", "compName","nciDomainValue", "compLabel")]
  )
knitr::kable(cubeMetadata[ cubeMetadata$compType=="metadata",c("compName","compLabel")])
```

The next statements demonstrates how to create two RDF data cubes
according to the specfications in the excel spreadsheet. Note the
contents of the RDF data cube is read from the csv file given by
obsFileName in directory given by obsFileNameDirectory. The value
```!example´´´ specifies that the file should be read from sample data
in the package. The dataCubeOutDirectory give the directory name for
the generated RDF data cube.

```{r, eval=TRUE}
dm.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "DM" )
cat("DM cube stored as ", dm.cube.fn, "\n")

ae.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "AE" )
cat("AE cube stored as ", ae.cube.fn, "\n")
```

Notes 
-----
In the read.xlsx, if all cells in a column is missing, then the input fails.  

Future version may replace the use of the DomainName, eg. DM and AE in
the examples above, with another way of deriving identification of the
table 

The attribute denominator may be changed to a dimension to handle more
complex situations. For example if there are percentages for TRT01A
and SEX using respectively TRT01A and SEX as denominator. This will be
represented by two observations with by definition the same dimensions
but different value for the attribute denominator. However, this will
violate the intergrity constraints for a RDF Data Cube (TODO: Add IC
name).  

-----

# Input the generated turtle file

Now look at the generated cubes by loading the turle files. Note: by
specifying prefix the output contains is shown using the prefixes.
Note for future: This may be a disadvantage if the value of the
prefix, say ds, changes.

```{r, echo=FALSE, results='asis'}
dataCubeFile<- dm.cube.fn
# dataCubeFile<- ae.cube.fn
```

The rest of the code only depends on the value of dataCubeFile.
```{r, echo=FALSE}
checkCube <- new.rdf(ontology=FALSE)  # Initialize
load.rdf(dataCubeFile, format="TURTLE", appendTo= checkCube)
summarize.rdf(checkCube)
```

First set values for accessing the cube.
```{r, echo=FALSE}
dsdName<- GetDsdNameFromCube( checkCube )
domainName<- GetDomainNameFromCube( checkCube )
forsparqlprefix<- GetForSparqlPrefix( domainName )
```

The next statement shows the first 10 triples in the cube.
```{r, echo=FALSE}
observations1Rq<- paste( forsparqlprefix,
'
select *
where {?s ?p ?o .}
limit 10
',
"\n"
)
observations1<- sparql.rdf(checkCube, observations1Rq  )
knitr::kable(head(observations1))
```

The next statement shows the first 10 triples in the cube, where the subject is a qb:Observation.
```{r, echo=FALSE}
observations2Rq<-  paste( forsparqlprefix,
'
select *
where { ?s a qb:Observation ; ?p ?o .}
limit 10
',
"\n"                               
)
observations2<- sparql.rdf(checkCube, observations2Rq)
knitr::kable(head(observations2, 10))
```

The cube components are shown in the next output.
```{r, echo=FALSE}
componentsRq<- GetComponentSparqlQuery( forsparqlprefix, dsdName )
components<- as.data.frame(sparql.rdf(checkCube, componentsRq), stringsAsFactors=FALSE)
components$vn<- gsub("prop:","",components$p)
knitr::kable(print(components[,c("vn", "label")]))
```

The codelists are shown in the next output.
```{r, echo=FALSE}
codelistsRq<- GetCodeListSparqlQuery( forsparqlprefix, dsdName )
codelists<- as.data.frame(sparql.rdf(checkCube, codelistsRq), stringsAsFactors=FALSE)
codelists$vn<- gsub("prop:","",codelists$p)
codelists$clc<- gsub("code:","",codelists$cl)
knitr::kable(print(codelists[,c("vn", "clc", "prefLabel")]))
```

Notes
-----
instead of using gsub the codelist values should be obtained in  a more straightforward way

this involves a new version of the ph.recode function

the rrdf package could be extended to expand the URI using the Jena expandPrefix method

-----

The dimensions are shown in the next output.
```{r, echo=FALSE}
dimensionsRq <- GetDimensionsSparqlQuery( forsparqlprefix )
dimensions<- sparql.rdf(checkCube, dimensionsRq)
knitr::kable(dimensions)
```

Then the attributes as shown in the next output.
```{r, echo=FALSE}
attributesRq<- GetAttributesSparqlQuery( forsparqlprefix )
attributes<- sparql.rdf(checkCube, attributesRq)
knitr::kable(attributes)
```

And finally the SPARQL query for observations, showing only the first 10 observations.
```{r, echo=FALSE}
observationsRq<- GetObservationsSparqlQuery( forsparqlprefix, domainName, dimensions, attributes )
cat(observationsRq)
observations<- as.data.frame(sparql.rdf(checkCube, observationsRq ), stringsAsFactors=FALSE)
knitr::kable(observations[ 1:10 ,
   c(paste0(sub("prop:", "", dimensions), "value"),sub("prop:", "", attributes), "measure")])

```

Here is how to re-produce the metadata for the workbook.
First get the dimensions, measure and attribute

```{r, echo=FALSE}
workbookDimAttrMeasRq<- GetDimAttrMeasInWorkbookFormatSparqlQuery( forsparqlprefix ) 
dimensionsattr<- sparql.rdf(checkCube, workbookDimAttrMeasRq )
knitr::kable(dimensionsattr)
```

Secondly, get the metadata for the workbook. To get the metadata
element "cubeVersion" a workaround is needed. The cubeversion is not
directly available but from dcat:distribution derived as the result of
paste0("DC-", domainName,"-R-V-",cubeVersion,".TTL").
```{r, echo=FALSE}
workbookMetadataRq<- GetMetaDataInWorkbookFormatSparqlQuery( forsparqlprefix )
metadata<- sparql.rdf(checkCube, workbookMetadataRq)
cubeVersion<- gsub("-",".", gsub("DC-.*-R-V-([^\\.]+).TTL", "\\1", metadata[ metadata[,2]=="distribution", "compLabel"], perl=TRUE))
metadataX<- rbind(metadata, cbind(compType="metadata", compName="cubeVersion", compLabel=cubeVersion))
knitr::kable(metadataX)
```

For comparison, see the meta data from the excel workbook in the beginning of the document.

