---
title: "Data qubes from Workbook"
author: "PhuseSubTeamAnalysisResults@example.org"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data qubes from Workbookle}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---


### How to run from command prompt when developing

Start in the package root directory

Devtools should reply reply Loading rrdfqbcrnd0.

The knit command should generate .md file in the present work directory - the package root directory


```{r, eval=FALSE}
library(devtools)
devtools::load_all()

library(knitr)
knit("vignettes/cube-from-workbook.Rmd")
```

Generate the pdf file using the following command
```{r makepdf.sh, eval=FALSE, engine='bash'}
pandoc qube-from-workbook.md -o xx.pdf
```

The knitr::knit2html should generate a .html file in the present work directory - the package root directory

Generating HTML works nicely
```{r, eval=FALSE} 
knitr::knit2html("vignettes/qube-from-workbook.Rmd")
```

The following does not work as the texi2dvi can not handle the dollar signs in the bash code above.
I suppose some other options have to be given. The work around is to use pandoc on the .md file generated as mentioned above.

```{r, eval=FALSE}
knitr::knit2pdf("vignettes/qube-from-workbook.Rmd")
```

## Code


```{r, eval=TRUE}

library (rrdf)
library (xlsx)
library(rrdfqbcrnd0)



# NOTE: if all cells in a column is missing, then the input fails
RDFCubeWorkbook<- system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")

dm.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "DM" )
cat("DM cube stored as ", dm.cube.fn, "\n")

ae.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "AE" )
cat("AE cube stored as ", ae.cube.fn, "\n")


```


Now look at the generated cubes by loading the turle files. Note: by specifying prefix the output contains is shown using the prefixes.
Note for future: This may be a disadvantage if the value of the prefix, say ds, changes.

```{r, echo=FALSE, results='asis'}

dataCubeFile<- dm.cube.fn
# dataCubeFile<- ae.cube.fn
```

```{r, echo=FALSE}
# the rest of the code only depends on the value of dataCubeFile 
checkCube <- new.rdf(ontology=FALSE)  # Initialize
load.rdf(dataCubeFile, format="TURTLE", appendTo= checkCube)
summarize.rdf(checkCube)
# determine the domain name; used for defining prefixes
# TODO: reconsider the use of domain specific prefixes

# TODO: make this simpler - the only purpose is find the dsdName
# TODO: a qb:DataStructureDefinition, and for domainname, say, the DM in ds:dsd-DM
tempstr<- as.character(sparql.rdf(checkCube, "select ?s where { ?s a <http://purl.org/linked-data/cube#DataStructureDefinition> } limit 1"))
tempstrvec<- unlist(strsplit( tempstr, "/"))
dsdName<- tempstrvec[length(tempstrvec)]
domainName<- strsplit(dsdName,"-")[[1]][[2]]

data(qbCDISCprefixes)
common.prefixes <- data.frame(
    prefix=gsub("^prefix","",names(qbCDISCprefixes)),
    namespace=as.character(qbCDISCprefixes )
    )
custom.prefixes <-Get.qb.crnd.prefixes(tolower(domainName))

forsparqlprefix<- Get.rq.prefix.df(rbind(common.prefixes, custom.prefixes))
```

The next statement shows the first 10 triples in the cube.
```{r, echo=FALSE}

cube.observations1.rq<- paste( forsparqlprefix,
'
select *
where {?s ?p ?o .}
limit 10
',
"\n"
)

cube.observations1<- sparql.rdf(checkCube, cube.observations1.rq  )
knitr::kable(head(cube.observations1, 10))
```

The next statement shows the first 30 triples in the cube, where the subject is a qb:Observation.
```{r, echo=FALSE}

cube.observations2.rq<-  paste( forsparqlprefix,
'
select *
where { ?s a qb:Observation ; ?p ?o .}
limit 30
',
"\n"                               
)

cube.observations2<- sparql.rdf(checkCube, cube.observations2.rq)
knitr::kable(head(cube.observations2, 10))

```

The codelists are shown in the next output.
```{r, echo=FALSE}

codelists.rq<-   paste(forsparqlprefix,
'
select distinct ?p ?cl ?prefLabel
where {
?DataStructureDefinition a qb:DataStructureDefinition ;
   qb:component ?component .
?component a qb:ComponentSpecification .
?component qb:dimension ?p .
?p qb:codeList ?c .
?c skos:hasTopConcept ?cl .
?cl skos:prefLabel ?prefLabel .
values ( ?DataStructureDefinition ) {
',
paste0( "(", "ds:", dsdName, ")"),
'
}
}
order by ?p ?cl ?prefLabel
'
)

cube.codelists<- as.data.frame(sparql.rdf(checkCube, codelists.rq), stringsAsFactors=FALSE)
# TODO instead of gsub make a more straightforward way
# TOTO this involves a new version of the ph.recode function
cube.codelists$vn<- gsub("prop:","",cube.codelists$p)
cube.codelists$clc<- gsub("code:","",cube.codelists$cl)
knitr::kable(print(cube.codelists[,c("vn", "clc", "prefLabel")]))

```

The dimensions are shown in the next output.
```{r, echo=FALSE}

cube.dimensions.rq<- paste(forsparqlprefix,
'
select * where
{ [] qb:dimension ?p .  }
',
"\n"
)
cube.dimensions<- as.data.frame(sparql.rdf(checkCube, cube.dimensions.rq), stringsAsFactors=FALSE)
knitr::kable(print(cube.dimensions))

```

And finally the SPARQL query for observations.
```{r, echo=FALSE}

cube.dimensionsattr<- sparql.rdf(checkCube,
  paste(forsparqlprefix,
"select * where { {[] qb:dimension ?p . } union {  ?p a qb:AttributeProperty . } }"
))

cube.observations.rq<-  paste( forsparqlprefix,
    "select * where {",
    "?s a qb:Observation  ;", "\n",
    paste("       qb:dataSet",  paste0( "ds:", "dataset", "-", domainName), " ;", sep=" ", collapse="\n"), "\n",
    paste0( cube.dimensionsattr, " ", sub("prop:", "?", cube.dimensionsattr), ";", collapse="\n"),
    "\n",
    "prop:measure      ?measure ;      \n",
    paste0( "optional{ ", sub("prop:", "?", cube.dimensionsattr), " ",
           "skos:prefLabel",
           " ",
           sub("prop:", "?", cube.dimensionsattr), "value" ,
           " . ", "}",
           collapse="\n"),
    "\n",
    "} ",
    "\n"
   )

```

This is the query for getting the observations
```{r, echo=FALSE}

cat(cube.observations.rq)
```

And finally the observations.
```{r, echo=FALSE}


cube.observations<- as.data.frame(sparql.rdf(checkCube, cube.observations.rq ), stringsAsFactors=FALSE)
knitr::kable(cube.observations[,c(paste0(sub("prop:", "", cube.dimensionsattr), "value"),"measure")])


```
