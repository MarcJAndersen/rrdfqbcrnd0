---
title: "Demograhics (DM) table from CSV file"
author: "PhuseSubTeamAnalysisResults@example.org"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Demograhics (DM) table from CSV file}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---


## Prelimnaries
The present version uses Apache Fuseki to access CDISC in RDF from rdf.cdisc.org.

Here is how to make a local copy of the rdf.cdisc.org - with Bash Shell on Linux.


```{r get-rdf-cdisc-org.sh, eval=FALSE, engine='bash'}
echo change below to suit your setup
export CDISCRDF_HOME=~/projects/phrmwg-cdisc 
echo only if directory does not exist 
mkdir -p ${CDISCRDF_HOME}  
cd ${CDISCRDF_HOME}

git clone https://github.com/phuse-org/rdf.cdisc.org.git

mkdir rdf-data-cube
cd rdf-data-cube
wget http://publishing-statistical-data.googlecode.com/svn/trunk/specs/src/main/vocab/cube.ttl
cd ..

mkdir tdb

export JENA_HOME=/opt/apache-jena-2.12.1
${JENA_HOME}/bin/tdbloader2 --loc tdb rdf.cdisc.org/*/*.{ttl,owl} rdf-data-cube/*.ttl 
```

Start fuseki pointing to the TDB store created - note the update option makes it possible to upload triples as, say, turtle files.


```{r start-fuseki.sh, eval=FALSE, engine='bash'}
cd ${CDISCRDF_HOME}
export FUSEKI_HOME=/opt/jena-fuseki-1.1.1
${FUSEKI_HOME}/fuseki-server --pages=${FUSEKI_HOME}/pages --update --loc=tdb /cdisc
```

### How to run from command prompt when developing

Start in the package root directory

Devtools should reply reply Loading rrdfqbcrnd0.

The knit command should generate .md file in the present work directory - the package root directory


```{r, eval=FALSE}
library(devtools)
devtools::load_all()

library(knitr)
knit("vignettes/dm-table-from-csv.Rmd")
```

Generate the pdf file using the following command
```{r makepdf.sh, eval=FALSE, engine='bash'}
pandoc dm-table-from-csv.md -o xx.pdf
```

The knitr::knit2html should generate a .html file in the present work directory - the package root directory

Generating HTML works nicely
```{r, eval=FALSE} 
knitr::knit2html("vignettes/dm-table-from-csv.Rmd")
```

The following does not work as the texi2dvi can not handle the dollar signs in the bash code above.
I suppose some other options have to be given. The work around is to use pandoc on the .md file generated as mentioned above.

```{r, eval=FALSE}
knitr::knit2pdf("vignettes/dm-table-from-csv.Rmd")
```

## Code


```{r}

library (rrdf)
library (xlsx)
library(rrdfqbcrnd0)


#TW: To pass in as a parameter. Will have values: DM, AE, etc.
#   Must match the name in the workbook sheet (DM-components), etc.
#   Also used in cube name, dsd-<name> etc.
domainName="DM"

#------------  Declarations    ------------------------------------------------
endpoint<- "http://localhost:3030/cdisc/query"

# NOTE: For pav:Version (dot, notdash) and output file name
cubeVersion <- "0-5-3f"  # 0-5-3 using .XLSX for DM Skeleton  

# tempdir() not working on TW system. CHanged to getwd() plus added path to data folder
# dataOut <- tempdir()  # Input and output files: Used by MJA
dataOut <- paste0(getwd(), "/data/"  )

#DELgeneralprefixSourceFile<- system.file("extdata/sample-cfg", "CommonCubePrefixes.csv", package#DEL="rrdfqbcrnd0")
#DELprint(paste0("Reading from ", generalprefixSourceFile ))
#DELif (! file.exists(generalprefixSourceFile) ) {
#DEL  # consider using try instead
#DEL  stop( paste0("Expected file ", generalprefixSourceFile, " does not exist" ))
#DEL  }
#TW add in a check of the workbookif (! file.exists(specificprefixSourceFile) ) {
#  # consider using try instead
#  stop( paste0("Expected file ", specificprefixSourceFile, " does not exist" ))
#  }

############
# Prefixes #
###############################################################################
# Construct list to hold the prefix namespaces, 
# using format:prefixPREFIXNAME with key .
# Two sources:  Workbook sheet CubePrefixes , custom built on domain name
# Vars. used  later in the construction of cube skeleton and cube obs.
#   Examples: prefixQB   holds value http://purl.org/linked-data/cube#
#             prefixRDFS holds value http://www.w3.org/2000/01/rdf-schema#

RDFCubeWorkbook = system.file("extdata/sample-cfg", "RDFCubeWorkBook.xlsx", package="rrdfqbcrnd0")

# Get the prefixes
common.prefixes = read.xlsx(RDFCubeWorkbook,sheetName=paste0("CubePrefixes"))

# Create the domain-specific prefixes:for /prop/, /dccs/ and /dataset/
custom.prefixes <-data.frame(prefix=c("prop", "dccs", "ds"),
        namespace=c(paste0("http://www.example.org/dc/",domainName,"/prop/"),
                    paste0("http://www.example.org/dc/",domainName,"/dccs/"),
                    paste0("http://www.example.org/dc/",domainName,"/dataset/")
                    ))
prefixSource=rbind(common.prefixes, custom.prefixes)                                                

# Cube Observation data       
DMobsFile<- system.file("extdata/sample-cfg", "dm.AR.csv", package="rrdfqbcrnd0")

# should maybe get that from some other data - eg. stored in the cube
DMrecode.list= list(
    "sex"=list( 'F'='sex-F','M'='sex-M', '_ALL_'='sex-_ALL_' ),
    "race"= list('WHITE'='race-WHITE',
                       'BLACK OR AFRICAN AMERICAN'='race-BLACK_OR_AFRICAN_AMERICAN',
                       'AMERICAN INDIAN OR ALASKA NATIVE'='race-AMERICAN_INDIAN_OR_ALASKA_NATIVE',
                       '_ALL_'='race-_ALL_' ),
    "trt01a"=list('Placebo'='trt01a-Placebo',
                  'Xanomeline High Dose'='trt01a-Xanomeline_High_Dose',
                  'Xanomeline Low Dose'='trt01a-Xanomeline_Low_Dose',
                  '_ALL_'='trt01a-_ALL_' ),
    "saffl"=list('Y'='saffl-Y',
                        'N'='saffl-N',
                        '_ALL_'='saffl-_ALL_'),
    "factor"=list('quantity'='factor-QUANTITY',
                         'proportion'='factor-PROPORTION', 
                         'AGE'='factor-AGE' ),
    "procedure"= list('count'='procedure-COUNT',
                      'countdistinct'='procedure-COUNTDISTINCT',
                      'percent'='procedure-PERCENT', 
                      'mean'='procedure-MEAN', 
                      'stdev'='procedure-STDDEV', 
                      'min'='procedure-MIN', 
                      'median'='procedure-MEDIAN', 
                      'max'='procedure-MAX' )                        
     );

  procedure2format= list("count"="int",
                         "countdistinct"="int",
                            'percent'='double', 
                            'mean'='double', 
                            'stdev'='double', 
                            'min'='double', 
                            'median'='double', 
                            'max'='double'                         
     );

# Output file format: DC-<domain>-R-Vn-n-(n).TTL . Also used in dcat:distribution
DMdataCubeFileName  <- paste0("DC-", domainName,"-R-V-",cubeVersion,".TTL")   
DMdataCubeFile      <- paste0(dataOut,DMdataCubeFileName) # Full path to cube
  
storeDM = new.rdf(ontology=FALSE)  # Initialize

# register prefixes
DMprefixlist= qb.def.prefixlist(storeDM, prefixSource)

############
# Skeleton #
###############################################################################
# Read the skeleton  specifications to dataframe
# Source in file: compType, compName, compLabel
# TODO: Replace some use of compLabel with a var : compNameClass, formed by
#     : Upcase of first letter of the compName value.
DMCubeMetadata = read.xlsx(RDFCubeWorkbook,sheetName=paste0(domainName,"-Components"))
# Subset to the dimensions, attributes, and measure used to construct the skeleton
DMSkeletonSource <-DMCubeMetadata[grep("dimension|attribute|measure", DMCubeMetadata$compType),]

#TW Cube metadata. Show me a more efficient way to get the metadata values from the Workbook 
# and pass them into the fucntion as a string.

dfcubeDescription<-DMCubeMetadata[grep("description", DMCubeMetadata$compName),]
cubeDescription <- toString(dfcubeDescription$compLabel)

dfcubeComment<-DMCubeMetadata[grep("comment", DMCubeMetadata$compName),]
cubeComment<- toString(dfcubeComment$compLabel)

dfcubeLabel<-DMCubeMetadata[grep("label", DMCubeMetadata$compName),]
cubeLabel<-toString(dfcubeLabel$compLabel)


dfcubeTitle<-DMCubeMetadata[grep("title", DMCubeMetadata$compName),]
cubeTitle<-toString(dfcubeTitle$compLabel)

DMobsData = read.csv(DMobsFile) 
names(DMobsData)= tolower(names(DMobsData))

qb.buildSkeleton(storeDM, DMprefixlist, DMobsData, DMSkeletonSource)

qb.buildDSD(storeDM, DMprefixlist, DMobsData, DMSkeletonSource,
            dsdURIwoprefix=paste0("dataset-",domainName),
            dsdName=paste0("dsd-",domainName),
            extra=list(description=cubeDescription,
              comment=cubeComment,
              label=cubeLabel,
              distribution=DMdataCubeFileName,
              obsfilename=DMobsFile,
              title=cubeTitle
               ),
            remote.endpoint=endpoint
          )

qb.buildObservations( store=storeDM, prefixlist=DMprefixlist, obsData=DMobsData, skeletonSource=DMSkeletonSource, dsdURIwoprefix=paste0("dataset-", domainName), recode.list=DMrecode.list, procedure2format=procedure2format )

##########
# Output #
###############################################################################
DMoutcube = save.rdf(storeDM, filename=DMdataCubeFile, format="TURTLE")

###############################################################################
```


Now look at the cube. Note: by specifying prefix the output contains is shown using the prefixes.
Note for future: This may be a disadvantage if the value of the prefix, say ds, changes.

```{r, echo=FALSE, results='asis'}

checkDM = new.rdf(ontology=FALSE)  # Initialize
load.rdf(DMdataCubeFile, format="TURTLE", appendTo= checkDM)
summarize.rdf(checkDM)


## ------------------------------------------------------------------------

myprefixes= list(
 "rdf"= "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ,
 "skos"="http://www.w3.org/2004/02/skos/core#" ,
 "prov"="http://www.w3.org/ns/prov#" ,
 "rdfs"="http://www.w3.org/2000/01/rdf-schema#" ,
 "dcat"="http://www.w3.org/ns/dcat#" ,
 "owl"= "http://www.w3.org/2002/07/owl#" ,
 "xsd"= "http://www.w3.org/2001/XMLSchema#" ,
 "qb"=  "http://purl.org/linked-data/cube#" ,
 "pav"= "http://purl.org/pav" ,
 "dct"= "http://purl.org/dc/terms/" ,
 "mms"= "http://rdf.cdisc.org/mms#" ,
 "cts"= "http://rdf.cdisc.org/ct/schema#" ,
 "dccs"="http://www.example.org/dc/DM/dccs/" ,
 "code"="http://www.example.org/dc/code/" ,
 "ds"=  "http://www.example.org/dc/DM/dataset/" ,
 "prop"="http://www.example.org/dc/DM/prop/",
 "valid"="http://www.example.org/dc/DM/valid/"
)  ;


forsparqlprefix= paste("prefix", paste(names(myprefixes),":",sep=""), paste("<",myprefixes,">",sep=""),sep=" ",collapse=" ")

cube.observations1= sparql.rdf(checkDM,
   paste( forsparqlprefix,
     "select * where {?s ?p ?o .} limit 10"
     )
   );
knitr::kable(head(cube.observations1, 10))


cube.observations2= sparql.rdf(checkDM,
   paste( forsparqlprefix,
     "select * where { ?s a qb:Observation ; ?p ?o .}"
     )
   );
knitr::kable(head(cube.observations2, 10))
```
