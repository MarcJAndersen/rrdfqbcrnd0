---
title: "Two dimensional representation of RDF data cube"
author: "PhuseSubTeamAnalysisResults@example.org"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Two dimensional representation of RDF data cube}
  %\VignetteEngine{knitr::knitr}
  %\usepackage[utf8]{inputenc}
  %\SweaveUTF8
---

# Setup

First load the package.
```{r, eval=TRUE}
library(rrdfqbcrnd0)
```

# Generating RDF data cube from specification in a spreadsheet and export as turtle file

The generation of RDF data cube can be specified in a spreadsheet.

## DM data 
The outputs below shows the generation of the DM RDF data cube.

```{r, eval=TRUE}
RDFCubeWorkbook<- system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")
dm.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "DM" )
cat("DM cube stored as ", dm.cube.fn, "\n")
```

## DEMO data 
The outputs below shows the generation of the DEMO RDF data cube.


```{r, eval=TRUE}
RDFCubeWorkbook<- system.file("extdata/sample-cfg", "RDFCubeWorkbook.xlsx", package="rrdfqbcrnd0")
demo.cube.fn<- BuildCubeFromWorkbook(RDFCubeWorkbook, "DEMO" )
cat("DEMO cube stored as ", demo.cube.fn, "\n")

dataCubeFile<- demo.cube.fn
checkCube <- new.rdf()  # Initialize
load.rdf(dataCubeFile, format="TURTLE", appendTo= checkCube)
summarize.rdf(checkCube)

dsdName<- GetDsdNameFromCube( checkCube )
domainName<- GetDomainNameFromCube( checkCube )
forsparqlprefix<- GetForSparqlPrefix( domainName )
```

View observation "ds:obs7"

```{r, eval=TRUE}
cube.observations.rq<-  paste( forsparqlprefix,
'
select *
where { 
?s a qb:Observation ; 
?p ?o .
values (?s) {
(ds:obs7)
}
}
limit 30
',
"\n"                               
)

cube.observations<- sparql.rdf(checkCube, cube.observations.rq)
knitr::kable(head(cube.observations, 10))

```

## Create the two dimensional representation

For sex, race and factor show the label and the level if the level is not _ALL_.
If factor is code:factor-AGE then show the label.
Allocate 1 rightmost columns for the procedure.
Allocate 1 rightmost columns for unit, show it if not _NULL_.

```{r, echo=TRUE}
dimensions<- sparql.rdf(checkCube, GetDimensionsSparqlQuery( forsparqlprefix ) )
attributesDf<- sparql.rdf(checkCube, GetAttributesSparqlQuery( forsparqlprefix ))

## rowdim<- setdiff(union(dimensions,attributesDf), c("prop:saffl"))
## rowdim<- union(dimensions,attributesDf), c("prop:saffl")

## rowdim<- c("prop:saffl", "prop:race", "prop:sex", "prop:factor",
## "prop:procedure", "prop:unit", "prop:denominator" )

rowdim<- c("prop:agegr1", "prop:race", "prop:ethnic", "prop:sex", "prop:factor",
"prop:procedure", "prop:unit", "prop:denominator" )

coldim<- c("prop:trt01a")

qbtest<- GetTwoDimTableFromQb( checkCube, forsparqlprefix, domainName, rowdim, coldim )

qbtest
names(attributes(qbtest))

## attr(qbtest,"obsURI")

## show the data frame with measures for observations and dimensions and attributes
qbtest
## show the rowLabel dataset
rowLabel<- attr(qbtest,"rowLabelDf")
rowLabel
prColspan<- data.frame( unit=integer(nrow(qbtest)), proc=integer(nrow(qbtest)), idcol1= integer(nrow(qbtest)), stringsAsFactors=FALSE  )
prIdCol<- data.frame( procedurevalue=character(nrow(qbtest)), unitvalue=character(nrow(qbtest)), stringsAsFactors=FALSE )
rowno<-5
rowid<- rowdim[1]
## travers all values to determine number of identification columns
Nidcol<- 1
for (rowno in 1:nrow(qbtest)) {
  prIdCol$procedurevalue[rowno]<- rowLabel$value[ rowLabel$codeval==qbtest$procedure[rowno] ]
  prIdCol$unitvalue[rowno]<- qbtest$unit[rowno]
  currNidcol<-0
  if (qbtest$factor[rowno] %in% c("code:factor-proportion", "code:factor-quantity") ) {
     for (rowid in setdiff(rowdim,c("prop:procedure","prop:unit", "prop:denominator"))) {
       currRowLabel<- rowLabel$variable==gsub("prop:", "", rowid) & rowLabel$codeval==qbtest[rowno,gsub("prop:", "", rowid)]
       if ( rowLabel$value[ currRowLabel ] != "_ALL_" ) {
         currNidcol<- currNidcol+1
         prIdCol[rowno, paste0("idcollabel",currNidcol ) ]<- rowLabel$label[ currRowLabel ]
         prIdCol[rowno, paste0("idcolvalue",currNidcol ) ]<- rowLabel$value[ currRowLabel ]
       }
     }
     }
    else {
      for (rowid in setdiff(rowdim,c("prop:procedure","prop:unit", "prop:denominator"))) {
        currRowLabel<- rowLabel$variable==gsub("prop:", "", rowid) & rowLabel$codeval==qbtest[rowno,gsub("prop:", "", rowid)]
        if ( rowLabel$value[ currRowLabel ] != "_ALL_" ) {
          currNidcol<- currNidcol+1
          ## XX for now only descriptive statistics
          prIdCol[rowno, paste0("idcollabel",currNidcol ) ]<- rowLabel$value[ currRowLabel ]
          prIdCol[rowno, paste0("idcolvalue",currNidcol ) ]<- " "
        }
      }
    }
     Nidcol<- max( Nidcol, currNidcol )
   }
  
pr2IdCol<-   prIdCol[,c(paste0("idcolvalue",1:Nidcol),"procedurevalue", "unitvalue")]
pr2IdCol

rowdisplay<- c( "prop:sex", "prop:race", "prop:factor",  "prop:procedure",  "prop:unit", "prop:denominator")

presTable<- qbtest
colnoseq<- attr(qbtest,"colnoseq")
rownoseq<- attr(qbtest,"rownoseq")
observationsDesc<-attr(qbtest,"observationsDesc")
for (colno in colnoseq) {
   presTable[,paste0("col", colno)]<- rep( NA, length(rownoseq))
 }
for (colno in colnoseq) {
   for (rowno in rownoseq) {
     presTable[rowno,paste0("col", colno)]<- observationsDesc[observationsDesc$rowno==rowno & observationsDesc$colno==colno, "measure"]
}
}

presTable

```

Approach for making html code see library(Hmisc), html.data.frame.
To make the usual N, % - introduce a new attibute sub column with 1 for N and 2 for %, 1 for all other statistics. Then the table can be made by defining columns from TRT01A and sub column.

```{r, echo=TRUE}
colLabel<- attr(qbtest,"colLabelDf")
colLabel
options(width=300)
file<- file.path(system.file("extdata/sample-cfg", package="rrdfqbcrnd0"), "test.html")
# file<- file.path(tempdir(),"test.html")
append<- TRUE
print(file)
oD<-attr(qbtest,"observationsDesc")
names(oD)
cat("<table border>\n", file=file, append=FALSE)
or<-1
unique(oD$rowno)
unique(oD$colno)
presrowvarvalue<- gsub("prop:(.*)","\\1value",rowdim)
presrowvarIRI<- gsub("prop:(.*)","\\1IRI",rowdim)
presrowvarlabel<- gsub("prop:(.*)","\\1label",rowdim)
presrowvarindex<- 1:length(rowdim)
## make the header row(s) for the columns
## TODO the code below does only work for this special case
  for (vi in presrowvarindex) {
    cat("<th>", file=file, append=TRUE)
      ## next line is for simple fly-over
      cat(paste0("<a title=\"", oD[1, presrowvarIRI[vi]], "\">", oD[or,presrowvarlabel[vi]], "</a>"), file=file, append=TRUE)
    cat("</th>", file=file, append=TRUE)
    }
  for (cc in unique(oD$colno)) {
    cat("<th>", file=file, append=TRUE)
      cat(paste0("<a title=\"", colLabel$codeval[cc], "\">", colLabel$value[cc], "</a>"), file=file, append=TRUE)
      }
    cat("</th>", file=file, append=TRUE)

cat("</tr>", file=file, append=TRUE)
for (rr in unique(oD$rowno)) {
  cat("<tr>", file=file, append=TRUE)
  ## make the row identification
  for (vi in presrowvarindex) {
    cat("<td>", file=file, append=TRUE)
      ## next line is for simple fly-over
      cat(paste0("<a title=\"", oD[or, presrowvarIRI[vi]], "\">", oD[or,presrowvarvalue[vi]], "</a>"), file=file, append=TRUE)
    cat("</td>", file=file, append=TRUE)
    }
  for (cc in unique(oD$colno)) {
    cat("<td>", file=file, append=TRUE)
    if (oD$rowno[or]==rr & oD$colno[or]==cc) {
##      cat(paste0("<a href=\"", oD$measureIRI[or], "\">", oD$measure[or], "</a>"), file=file, append=TRUE)
      ## next line is for simple fly-over
      cat(paste0("<a title=\"", oD$measureIRI[or], "\">", oD$measure[or], "</a>"), file=file, append=TRUE)
      or<- or+1
      }
    cat("</td>", file=file, append=TRUE)
  }
cat("</tr>", file=file, append=TRUE)
  }
cat("</table>\n", file=file, append=TRUE)

```


# Session information
```{r, echo=TRUE}
sessionInfo()
```

