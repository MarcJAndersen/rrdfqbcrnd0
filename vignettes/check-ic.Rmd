---
title: "Execute SPARQL integrity constraints on a data cube"
author: "mja@statgroup.dk"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Execute SPARQL integrity constraints on a data cube}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, results='asis', eval=TRUE}

library(rrdfqbcrnd0)


qbfile<- system.file("extdata/sample-rdf", "DC-DM-sample.TTL", package="rrdfqbcrnd0")
cube<- load.rdf( qbfile, format="TURTLE")

dsdName<- GetDsdNameFromCube( cube )
domainName<- GetDomainNameFromCube( cube )
forsparqlprefix<- GetForSparqlPrefix( domainName )

cdisc.rdf<- Load.cdisc.standards()

cubeData<- combine.rdf( cube, cdisc.rdf)

ic1<- "ASK {
  {
    # Check observation has a data set
    ?obs a qb:Observation .
    FILTER NOT EXISTS { ?obs qb:dataSet ?dataset1 . }
  } UNION {
    # Check has just one data set
    ?obs a qb:Observation ;
       qb:dataSet ?dataset1, ?dataset2 .
    FILTER (?dataset1 != ?dataset2)
  }
}"

```
rrdf does not implement the ASK query. As a word around use transform to, most likely more inefficient, a `SELECT (COUNT(*) ...)` query.

```{r, results='asis', eval=TRUE}

## ic1Select<- gsub("ASK \\{", "SELECT (COUNT(*) AS ?nfail) WHERE \\{", ic1)
## ic1SelectRq<- gsub("ASK \\{", "SELECT \\* WHERE \\{", ic1)
## cat(ic1SelectRq)
## cube.ic1<- sparql.rdf(cubeData, paste( forsparqlprefix, ic1SelectRq  )  )
## print(cube.ic1)

## backward way to select elements
for (icno in (1:length(qbIClist))) {
##  print(names(qbIClist[icno]))
  if (! (names(qbIClist[icno]) %in% c("ic-20", "ic-21")) ) {
    ic<- qbIClist[[icno]]
    icSelectRq<- gsub("ASK \\{", "SELECT \\* WHERE \\{", ic)
##    cat(unlist(strsplit(icSelectRq,"\n"))[1])
    cube.ic<- sparql.rdf(cubeData, paste( forsparqlprefix, icSelectRq  )  )
    cat(paste0(unlist(strsplit(icSelectRq,"\n"))[1], ": ", nrow(cube.ic), "\n"))
   }
}

```

For IC-20 special handling is needed.
IC-20 is a template and the value of p should be inserted as $p in the template 

```{r, results='asis', eval=TRUE}
instantiationRq<- "
SELECT ?p WHERE {
    ?hierarchy a qb:HierarchicalCodeList ;
                 qb:parentChildProperty ?p .
    FILTER ( isIRI(?p) )
}
"
p<- sparql.rdf(cubeData, paste( forsparqlprefix, icSelectRq  )  )
print(p)
```

For IC-21 special handling is needed.
IC-21 is a template and the value of p should be inserted as $p in the template 

```{r, results='asis', eval=TRUE}
instantiationRq<- "
SELECT ?p WHERE {
    ?hierarchy a qb:HierarchicalCodeList;
                 qb:parentChildProperty ?pcp .
    FILTER( isBlank(?pcp) )
    ?pcp  owl:inverseOf ?p .
    FILTER( isIRI(?p) )
}
"
p<- sparql.rdf(cubeData, paste( forsparqlprefix, icSelectRq  )  )
print(p)
```
